<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>Строки | var sity;</title>
        <meta charset="utf-8">
        <meta name="description" content="Руководство по основам JavaScript.">
        <link rel="stylesheet" href="style/varsity.css" media="all">
        <link rel="stylesheet" href="style/print.css" media="print">
        <!--[if lt IE 9]> <script src="javascript/html5.js"></script> <![endif]-->
        <link rel="icon" href="image/favicon.ico" type="image/x-icon">
        <link rel="shortcut icon" href="image/favicon.ico" type="image/x-icon">
    </head>
    <body>

        <!-- Mobile navigation-->
        <nav id="nav_mobile">
            <a id="nav_prev_section" style="">предыдущая глава<span class="nav_section_name"></span></a>
            <a id="nav_next_section" style="">следующая глава<span class="nav_section_name"></span></a>
            <a id="show_menu">показать меню</a>
        </nav>
        <section id="strings">
            <!-- Introduction-->
            <header id="strings.intro">
                <div id="logostrings" class="logo">
                    <a href="index.html"><img alt="Главная" src="image/Untitled-1a.png" title="Главная" height="150" /></a>
                </div>
                <h1>Строки</h1>
            </header>
            <!-- Articles-->
            <article id="strings.creation">
                <div>
                    <h2>Создание строк</h2>
                    <p>
                        Строки создаются при помощи двойных или одинарных кавычек:
                    </p>
                    <pre><code>var text = "моя строка";

var anotherText = 'еще строка';

var str = "012345";</code></pre>
                    <p>
                        В JavaScript <strong>нет разницы между двойными и одинарными кавычками</strong>.
                    </p>
                    <p>
                        Строки могут содержать специальные символы. Самый часто
                        используемый из таких символов - это <em>перевод строки</em>.
                    </p>
                    <p>
                        Он обозначается как <code>\n</code>, например:
                    </p>
                    <pre><code>alert('Привет\nМир'); // выведет "Мир" на новой строке</code></pre>
                    <p>
                        Есть и более редкие символы, вот их список:
                    </p>
                    <p>
                        <strong>Специальные символы</strong>
                    </p>
                    <pre><code><strong>Символ		Описание</strong>
\b		Backspace
\f		Form feed
\n		New line
\r		Carriage return
\t		Tab
\uNNNN		Символ в кодировке Юникод с шестнадцатиричным кодом NNNN</code></pre>
                    <p>
                        Если строка в одинарных кавычках, то внутренние одинарные кавычки
                        внутри должны быть <em>экранированы</em>, то есть снабжены обратным
                        слешем <code>\'</code>, вот так:
                    </p>
                    <pre><code>var str = 'I\'m a JavaScript programmer';</code></pre>
                    <p>В двойных кавычках &#8212; экранируются внутренние двойные:</p>
                    <pre><code>var str = "I'm a JavaScript \"programmer\" ";
alert(str);</code></pre>
                    <p>
                        Экранирование служит исключительно для правильного восприятия
                        строки JavaScript. <strong>В памяти строка будет содержать
                            сам символ без <code>'\'</code></strong>. Вы можете увидеть это, запустив пример выше.
                    </p>
                    <p>
                        Сам символ обратного слэша <code>'\'</code>
                        является служебным, поэтому всегда экранируется, т.е пишется как
                        <code>\\</code>:
                    </p>
                    <pre><code>var str = ' символ \\ ';

alert(str); // символ \</code></pre>
                    <p>
                        Заэкранировать можно любой символ. Если он не специальный, то
                        ничего не произойдёт:
                    </p>
                    <pre><code>alert( "\a" ); // a
// идентично alert( "a" );</code></pre>
                </div>
            </article>
            <article id="strings.peoperties">
                <div>
                    <h2>Cвойства строк</h2>
                    <p>
                        Одно из самых частых действий со строкой &#8212; это
                        получение ее длины:
                    </p>
                    <pre><code>var str = "My\n"; // 3 символа. Третий - перевод строки

alert(str.length);  // 3</code></pre>
                    <aside>
                        <p>
                            В современных браузерах (кроме IE&lt;8) для доступа к символу
                            можно также использовать квадратные скобки. Разница между этим способом и
                            <code>charAt</code> заключается в том, что если символа нет &#8212;
                            <code>charAt</code>
                            выдает пустую строку, а скобки &#8212;
                            <code>undefined</code>
                        </p>
                    </aside>
                    <p>
                        Чтобы получить символ, используйте вызов
                        <code>charAt(позиция)</code>. Первый символ имеет позицию<code>0</code>:
                    </p>
                    <pre><code>var str = "jQuery";
alert( str.charAt(0) );  // "j"</code></pre>
                    <p>
                        В JavaScript <strong>нет отдельного типа &laquo;символ&raquo;</strong>, так что
                        <code>charAt</code> возвращает строку, состоящую из выбранного символа.
                    </p>
                    <p>
                        Обратите внимание, <code>str.length</code> - это <em>свойство</em> строки, а
                        <code>str.charAt(pos)</code> - <em>метод</em>, т.е. функция.
                        Обращение к методу всегда идет со скобками, а к свойству
                        - без скобок.
                    </p>
                    <p>
                        <strong>Строки в JavaScript нельзя изменять.</strong> Можно
                        прочитать символ, но нельзя заменить его. Как только строка создана
                        &#8212; она такая навсегда.
                    </p>
                    <p>
                        Чтобы это обойти, создаётся новая строка и присваивается в
                        переменную вместо старой:
                    </p>
                    <pre><code>var str = "строка";

str =  str.charAt(3) + str.charAt(4) + str.charAt(5);

alert(str); // ока</code></pre>
                </div>
            </article>
            <article id="strings.methods">
                <div>
                    <h2>Методы строк</h2>
                    <p>
                        Методы <code>toLowerCase()</code> и <code>toUpperCase()</code>
                        меняют регистр строки на нижний/верхний:
                    </p>
                    <pre><code>alert( "Интерфейс".toUpperCase() ); // ИНТЕРФЕЙС</code></pre>
                    <p>
                        Пример ниже получает первый символ и приводит его к нижнему
                        регистру:
                    </p>
                    <pre><code>alert( "Интерфейс".charAt(0).toLowerCase() ); // 'и'</code></pre>
                    <p>
                        Мы не можем просто заменить первый символ, т.к. строки в
                        JavaScript неизменяемы.
                    </p>
                    <p>
                        Единственный способ - пересоздать строку на основе
                        существующей, но с заглавным первым символом:
                    </p>
                    <pre><code>function ucFirst(str) {
  var newStr = str.charAt(0).toUpperCase();

  for(var i=1; i&lt;str.length; i++) {
    newStr += str.charAt(i);
  }

  return newStr;
}

alert( ucFirst("вася") );</code></pre>
                    <p>
                        Для поиска подстроки есть метод <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String/indexOf">indexOf(подстрока[,
                            начальная_позиция])</a>.
                    </p>
                    <p>
                        Он возвращает позицию, на которой находится
                        <code>подстрока</code> или
                        <code>-1</code>, если ничего не найдено. Например:
                    </p>
                    <pre><code>var str = "Widget with id";

alert( str.indexOf("Widget") ); // 0, т.к. "Widget" найден прямо в начале str
alert( str.indexOf("id") ); // 1, т.к. "id" найден, начиная с позиции 1
alert( str.indexOf("Lalala") ); // -1, подстрока не найдена</code></pre>
                    <p>
                        Необязательный второй аргумент позволяет искать, начиная с
                        указанной позиции. Например, первый раз
                        <code>"id"</code> появляется на позиции <code>1</code>. Чтобы найти его следующее появление - запустим поиск с позиции <code>2</code>:
                    </p>
                    <pre><code>var str = "Widget with id";

alert( str.indexOf("id", 2) ) // 12, поиск начат с позиции 2</code></pre>
                    <p>
                        Также существует аналогичный метод <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String/lastIndexOf">lastIndexOf</a>,
                        который ищет не с начала, а с конца строки.
                    </p>
                    <p>
                        Для красивого вызова <code>indexOf</code> применяется побитовый оператор НЕ <code>'~'</code>.
                    </p>
                    <p>
                        Дело в том, что вызов <code>~n</code> эквивалентен выражению <code>-(n+1)</code>, например:
                    </p>
                    <pre><code>alert( ~2 ); // -(2+1) = -3
alert( ~1 ); // -(1+1) = -2
alert( ~0 ); // -(0+1) = -1

alert( ~-1 ); // -(-1+1) = 0 </code></pre>
                    <p>
                        Как видно, <code>~n</code> - ноль только в случае, когда <code>n == -1</code>.
                    </p>
                    <p>
                        То есть, проверка <code>if ( ~str.indexOf(...) )</code>
                        означает, что результат <code>indexOf</code> отличен от `-1, т.е. совпадение есть.
                    </p>
                    <pre><code>var str = "Widget";

if( ~str.indexOf("get") ) {
  alert('совпадение есть!');
}</code></pre>
                    <p>
                        Вообще, использовать возможности языка неочевидным образом
                        не рекомендуется, поскольку ухудшает читаемость кода.
                    </p>
                    <p>
                        Однако, в данном случае, все в порядке. Просто запомните:
                        <code>'~'</code> читается как &laquo;не минус один&raquo;, а
                        <code>"if ~str.indexOf"</code> читается как
                        <code>"если найдено"</code>.
                    </p> 
                    <p>
                        В JavaScript существуют целых 3 (!) метода для взятия
                        подстроки, с небольшими отличиями между ними.
                    </p>
                    <ol>
                        <li>
                            <p>
                                <code>substring(start [, end))</code>. Метод <code>substring(start, end)</code>
                                возвращает подстроку с позиции <code>start</code>
                                до, но не включая <code>end</code>.
                            </p>
                            <pre><code>var str = "stringify";
alert(str.substring(0,1)); // "s", символы с позиции 0 по 1 не включая 1.</code></pre>
                            <p>
                                Если аргумент <code>end</code> отсутствует, то идет до конца строки:
                            </p>
                            <pre><code>var str = "stringify";
alert(str.substring(2)); // ringify, символы с позиции 2 до конца</code></pre>
                        </li>
                        <li>
                            <p>
                                <code>substr(start [, length])</code>. Первый аргумент имеет такой же смысл, как и в
                                <code>substring</code>, а второй содержит не конечную позицию, а количество символов.
                            </p>
                            <pre><code>var str = "stringify";
str = str.substr(2,4); // ring, со 2й позиции 4 символа 
alert(str)</code></pre>
                            <p>
                                Если второго аргумента нет - подразумевается &laquo;до
                                конца строки&raquo;.
                            </p>
                        </li>
                        <li>
                            <p>
                                <code>slice(start [, end])</code>. Возвращает часть строки от позиции
                                <code>start</code> до, но не включая, позиции
                                <code>end</code>. Смысл параметров - такой же как в
                                <code>substring</code>.
                            <p>
                        </li>
                    </ol>
                    <p>
                        <strong>Различие между <code>substring</code> и <code>slice</code>
                            - в том, как они работают с отрицательными и выходящими за границу
                            строки параметрами:
                        </strong>
                    </p>
                    <ul>
                        <li>
                            <p>
                                <code>substring(start, end)</code>. Отрицательные аргументы интерпретируются как равные нулю. Слишком
                                большие значения усекаются до длины строки:
                            <pre><code>alert( "testme".substring(-2) );  // "testme", -2 становится 0</code></pre>
                            <p>
                                Кроме того, если <code>start &gt; end</code>, то аргументы меняются местами, т.е. возвращается участок строки
                                <em>между</em> <code>start</code> и <code>end</code>:
                            </p>
                            <pre><code>alert( "testme".substring(4, -1) );  // "test"
// -1 становится 0 -&gt; получили substring(4, 0) 
// 4 &gt; 0, так что аргументы меняются местами -&gt; substring(0, 4) = "test"</code></pre>
                        </li>
                        <li>
                            <p>
                                <code>slice</code>. Отрицательные значения отсчитываются от конца строки:
                            </p>
                            <pre><code>alert( "testme".slice(-2) );  // "me", от 2 позиции с конца</code></pre>
                            <pre><code>alert( "testme".slice(1, -1) ); // "estm", от 1 позиции до первой с конца.</code></pre>
                            <p>
                                Это гораздо более удобно, чем странная логика <code>substring</code>.<br />
                            </p>
                        </li>
                    </ul>
                    <p>
                        Отрицательное значение <code>start</code> также поддерживается в <code>substr</code> во всех браузерах, кроме IE.
                    </p>
                </div>
            </article>
            <article id="strings.unicode">
                <div>
                    <h2>Кодировка Юникод</h2>
                    <p>
                        Если вы знакомы со сравнением строк в других языках, то
                        позвольте предложить одну маленькую загадку. Даже не одну, а целых
                        две.</p>
                    <p>
                        Как мы знаем, символы сравниваются в алфавитном порядке
                        <code>'А' &lt; 'Б' &lt; 'В' &lt; ... &lt; 'Я'</code>.
                    </p>
                    <p>Но есть несколько странностей..</p>
                    <ol>
                        <li>
                            <p>
                                Почему буква <code>'а'</code> маленькая больше буквы <code>'Я'</code>
                                большой?
                            </p>
                            <pre><code>alert( 'а' &gt; 'Я' ); // true</code></pre>
                        </li>
                        <li>
                            <p>
                                Буква <code>'ё'</code> находится в алфавите между <code>е</code>
                                и <code>ж</code>: <code>абвгде<strong>ё</strong>жз..
                                </code>. Но почему тогда <code>'ё'</code> больше <code>'я'</code>?
                            </p>
                            <pre><code>alert( 'ё' &gt; 'я' ); // true</code></pre>
                        </li>
                    </ol>
                    <p>
                        Чтобы разобраться с этим, обратимся к внутреннему
                        представлению строк в JavaScript.
                    </p>
                    <p>
                        <strong>Все строки имеют внутреннюю кодировку <a href="http://ru.wikipedia.org/wiki/%D0%AE%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4">Юникод</a>.
                        </strong>
                    </p>
                    <p>
                        Вообще, в мире много разных кодировок, и страница может быть
                        в любой из них. Но внутри JavaScript-интерпретатора все строки
                        находятся в кодировке юникод.</p>
                    <p>
                        Есть метод для получения символа по его цифровому коду <code>String.fromCharCode(code)</code>. Возвращает символ по коду
                        <code>code</code>:
                    </p>
                    <pre><code>alert( String.fromCharCode(1072) ); // 'а'</code></pre>
                    <p>
                        Метод для получения цифрового кода <code>str.charCodeAt(pos)</code>. Возвращает код символа на позиции <code>pos</code>. Отсчет позиции начинается с нуля.
                    </p>
                    <pre><code>alert( "абрикос".charCodeAt(0) ); // 1072, код 'а'</code></pre>
                    <p>
                        Теперь вернемся к примерам выше. Почему сравнения
                        <code>'ё' &gt; 'я'</code>
                        и
                        <code>'а' &gt; 'Я'</code>
                        дают такой странный результат?
                    </p>
                    <p>
                        Дело в том, что <strong>символы сравниваются не по
                            алфавиту, а по коду</strong>. У кого код больше &#8212; тот и больше. В
                        юникоде есть много разных символов. Славянским языкам соответствуют
                        коды примерно от 1024 до 1119.
                    </p>
                    <p>
                        Так их можно получить:
                    </p>
                    <pre><code>var s = '';
for (var i=1024; i&lt;=1119; i++) {
  s += String.fromCharCode(i);
}</code></pre>
                    <p>
                        Результат:
                    </p>
                    <pre><code>?ЁЂЃЄЅІЇЈЉЊЋЌ?ЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя?ёђѓєѕіїјљњћќ?ўџ</code></pre>
                    <p>
                        Промежуток взят &laquo;с запасом&raquo;, так что можно
                        увидеть некириллические символы в начале и в конце.
                    </p>
                    <p>
                        Мы можем увидеть из этого отрезка кодировки две вещи:
                    </p>
                    <ol>
                        <li>
                            <p>
                                <strong>Строчные буквы идут после заглавных,
                                    поэтому они всегда больше.</strong><br /> В частности, <code>'а'(код
                                    1072) &gt; 'Я'(код 1071)</code>.<br /> Кстати, то же самое и в
                                английском алфавите, там <code>'a' &gt; 'Z'</code>.
                            </p>
                        </li>
                        <li>
                            <p>
                                Ряд букв, например <code>ё</code>, находятся вне основного
                                алфавита.<br /> Это объясняет, почему <strong><code>'ё'(код
                                        1105) &gt; 'я'(код 1103)</code></strong>.
                            </p>
                        </li>
                    </ol>
                </div>
            </article>
            <article id="strings.comparation">
                <div>
                    <h2>Сравнение строк</h2>
                    <p>
                        Строки сравниваются <em>лексикографически</em>, в порядке &laquo;телефонного справочника&raquo;.
                    </p>
                    <p>
                        Сравнение строк <code>s1</code> и <code>s2</code> обрабатывается по следующему алгоритму:
                    </p>
                    <ol>
                        <li>
                            <p>
                                Сравниваются первые символы: <code>a = s1.charAt(0)</code>
                                и <code>b = s2.charAt(0)</code>. Если они одинаковы, то следующий
                                шаг, иначе, в зависимости от результата их сравнения, возвратить <code>true</code>
                                или <code>false</code>
                            </p>
                        </li>
                        <li>
                            <p>
                                Сравниваются вторые символы, затем третьи и так
                                далее&#8230; Если в одной строке закончились символы, то она
                                меньше. Если в обоих закончились - они равны.
                            </p>
                        </li>
                    </ol>
                    <p>
                        Спецификация языка определяет этот алгоритм более детально,
                        но смысл в точности соответствует порядку, по которому имена
                        заносятся в телефонный справочник.
                    </p>
                    <pre><code>"Z" &gt; "A" // true
"Вася" &gt; "Ваня" // true, т.к. с &gt; н
"aa" &gt; "a"  // true, т.к. начало совпадает, но в 1й строке больше символов</code></pre>
                    <p>
                        Обратим внимание на результат сравнения чисел в строковой
                        форме. Он может быть неверным.
                    </p>
                    <pre><code>alert("2" &gt; "14"); // true, т.к. это строки и "2" &gt; "1"</code></pre>
                    <p>
                        Чтобы получать верный результат, хотя бы один из аргументов
                        должен не быть строкой. Тогда и другой будет преобразован к числу:
                    </p>
                    <pre><code>alert(2 &gt; "14"); // false</code></pre>
                </div>
            </article>
            <article id="strings.test">
                <h2>Тест</h2>
                <div>                            
                    <p>
                        Попробуйте пройти тест, чтобы проверить, насколько хорошо вы усвоили информацию, изложенную в данном разделе.
                    </p>
                    <ul>
                        <li>Выберите один из вариантов в каждом из 5 вопросов</li>
                        <li>Нажмите на кнопку "Показать результат"</li>
                        <li>Скрипт не покажет результат, пока вы не ответите на все вопросы</li>
                        <li>Загляните в окно рядом с номером задания. Если ответ правильный, то там (+). Если вы ошиблись, там (-).</li>
                        <li>Чтобы сбросить результат тестирования, нажмите кнопку "Сбросить ответы"</li>
                    </ul>
                    <br/>


                    <script type="text/javascript" >
                        var res = "13421";
                    </script>

                    <form name="test"><ol>
                            <li><INPUT readonly="readonly" type="text" size="1" name="T1"/><strong> Не является специальным строчным символом:</strong><br/>
                                <input type="radio" name="Q1"/> \m<br />
                                <input type="radio" name="Q1"/> \b<br />
                                <input type="radio" name="Q1"/> \f<br />
                                <input type="radio" name="Q1"/> \u<br />
                                <br/></li><li><INPUT readonly="readonly" type="text" size="1" name="T2"/><strong> Определить длину строки можно с помощью:</strong><br/>
                                <input type="radio" name="Q2"/> Length<br />
                                <input type="radio" name="Q2"/> Str.count<br />
                                <input type="radio" name="Q2"/> Str.length<br />
                                <input type="radio" name="Q2"/> Chatcount<br />
                                <br/></li><li><INPUT readonly="readonly" type="text" size="1" name="T3"/><strong> <code> var str = ‘раз два три четыре пять’; alert(str.indexOf(“шесть”)</code></strong><br/>
                                <input type="radio" name="Q3"/> 0<br />
                                <input type="radio" name="Q3"/> Null<br />
                                <input type="radio" name="Q3"/> Пустое сообщение<br />
                                <input type="radio" name="Q3"/> -1<br />
                                <br/></li><li><INPUT readonly="readonly" type="text" size="1" name="T4"/><strong> В какой кодировке находятся строки внутри JavaScript-интерпретатора:</strong><br/>
                                <input type="radio" name="Q4"/> ISCII<br />
                                <input type="radio" name="Q4"/> Unicode<br />
                                <input type="radio" name="Q4"/> ASCII <br />
                                <input type="radio" name="Q4"/> MS-Windows<br />
                                <br/></li><li><INPUT readonly="readonly" type="text" size="1" name="T5"/><strong> Как найти первый X в строке?</strong><br/>
                                <input type="radio" name="Q5"/> <code> txt.indexOf('X');</code><br />
                                <input type="radio" name="Q5"/> <code> txt.find('X');</code><br />
                                <input type="radio" name="Q5"/> <code> txt.locate('X');</code><br />
                                <input type="radio" name="Q5"/> <code> txt.countTo('X');</code><br />
                            </li></ol>		
                        <P><TEXTAREA name="s1" rows="4" cols="70" readonly> </TEXTAREA> </P>
<INPUT onclick="check_me();" type="button" value="Показать результат"/>&nbsp;&nbsp;&nbsp;&nbsp; 
<INPUT type="reset" value="Сбросить ответы"/> 	 
</form> 
                               
                        </div>
            </article>
        </section>
	<!-- Footer-->
	<footer>
		<p>
			Студентка группы ВПС-09-3 <a href="mailto:cherchich@gmail.com">Мария Дзюба</a>, ХНУРЭ, Харьков - 2013
		</p>
	</footer>
    <script src="javascript/jquery.min.js"></script>
	<script src="javascript/prettify.js"></script>
	<script src="javascript/plugin.js"></script>
	<script src="javascript/varsity.js"></script>
</body>
</html>